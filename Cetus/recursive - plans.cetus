// Source code

Void printf(String format, Int... values);

Foo
{
	Int a;
	Int b;
	
	Foo New(Int a, Int b)
	{
		Declare Foo this;
		this.a = a;
		this.b = b;
		Return this;
	}
	
	Int* A(Foo this)
	{
		Return this.a;
	}
};

Void main()
{
	Foo foo = Foo.New(2, 3);
	printf("Starting at %i\n", foo.A());
	
	While (foo.A() < 6)
	{
		foo.A() = foo.A() + 1;
		printf("Loop %i\n", foo.A());
	};
	
	printf("Ending at %i\n", foo.A());
	Return;
};



----------------------------------------------------------------------------



// Compiler first pass
// Mostly just grab all the type and function information

// Available functions
Parameter(String type, String name)
	as "$type $name";
VarArgParameter(String type, String name)
	as "$type... $name";
Body(Int index)
	as "\{ $index=lexer.Index \}";
Function(String name, Parameter[] parameters, VarArgParameter? varArgParameter, String returnType, Body? body)
	as "$returnType $name \( (($varArgParameter | $parameters (, $parameters)* (, $varArgParameter)?) (,)?)? \) $body";
Field(String type, String name)
	as "$type $name";
Struct(String name, Field[] fields, Function[] functions)
	as "$name \{ ($fields | $functions)+ \}";
Program(Struct[] structs, Function[] functions)
	as "($structs | $functions)+";



Program(
[
	Struct("Foo", [Field("Int", "a"), Field("Int", "b")],
		[
			Function("New", [Parameter("Int", "a"), Parameter("Int", "b")], None, "Foo", Some(FOO.NEW BODY INDEX)),
			Function("A", [Parameter("Foo", "this")], None, "Int*", Some(FOO.A BODY INDEX),
		]),
],
[
	Function("printf", [Parameter("String", "format")], Some(Parameter("Int", "values")), "Void", None),
	Function("main", [], None, "Void", Some(MAIN BODY INDEX)),
]);



----------------------------------------------------------------------------



// Compiler second pass
// Generate any intermediary code needed to parse function bodies

// Available functions
Parameter(Type type, String name);
Body(Int index);
Function(String name, Parameter[] parameters, Parameter? varArgParameter, String returnType, Body? body);
Field(Type type, String name);
Struct(String name, Field[] fields, Function[] functions);
Program(Struct[] structs, Function[] functions);



Program(
[
	Struct("Foo", [Field(Int, "a"), Field(Int, "b")],
		[
			Function("New", [Parameter(Int, "a"), Parameter(Int, "b")], None, Foo, Some(FOO.NEW BODY INDEX)),
			Function("A", [Parameter(Foo, "this")], None, Int*, Some(FOO.A BODY INDEX),
			Function("Get_a", [Parameter(Foo, "this")], None, Int*, None),
			Function("Get_b", [Parameter(Foo, "this")], None, Int*, None),
		]),
],
[
	Function("printf", [Parameter(String, "format")], Some(Parameter(Int, "values")), Void, None),
	Function("main", [], None, Void, Some(MAIN BODY INDEX)),
	Function("Get_Foo.New", [Parameter(Type<Foo>, "type")], None, Foo.New, None),
	Function("Get_Foo.A", [Parameter(Type<Foo>, "type")], None, Foo.A, None),
	Function("Call_Foo.A", [Parameter(Foo, "this")], None, () => Foo.A(this), None),
]);



----------------------------------------------------------------------------



// Compiler third pass
// Now we get to the actual function definitions

// Available functions

/// Compiler functions
Define(Type type, String name, Value value)
	as "$type $name = $value";
Declare(Type type, String name)
	as "Declare $type $name";
Assign(Value target, Value value)
	as "$target = $value";
Return(Value? value)
	as "Return $value?";
While(Expression condition, Expression body)
	as "While ( $condition ) $body";
LessThan(Value left, Value right)
	as "$left < $right";
Add(Value left, Value right)
	as "$left + $right";

/// User functions
printf(String format, Value... values);
main();

/// Compiler-generated user functions
Foo.Get_a(Foo this)
	as "$this.a";
Foo.Get_b(Foo this)
	as "$this.b";
Get_Foo.New(Type<Foo> type)
	as "$type.New";
Get_Foo.A(Type<Foo> type)
	as "$type.A";
Call_Foo.A(Foo this)
	as "$this.A";



Foo.New(Int a, Int b)
{
	Declare(Foo, "this");
	Assign(Foo.Get_a(this), a);
	Assign(Foo.Get_b(this), b);
	Return(Some(this));
}

Foo.A(Foo this)
{
	Return(Foo.Get_a(this));
}

Main()
{
	Define(Foo, "foo", Get_Foo.New(Foo)(2, 3));
	printf("Starting at %i", Call_Foo.A(foo)());
	
	While(LessThan(Call_Foo.A(foo)(), 6),
	{
		Assign(Call_Foo.A(foo)(), Add(Call_Foo.A(foo)(), 1));
		printf("Loop %i", Call_Foo.A(foo)());
	});
	
	printf("Ending at %i", Call_Foo.A(foo));
	Return(None);
}